/*
	DATA TYPES IN POSTGRES : 
	1. DATETIMES WITH TIME ZONES
	2. TIME INTERVALS
	3. RANGES
	4. JSON
	5. XML
	.. SOME MORE DATA TYPES



*/

/******** NUMERICS ***********/

-- SERIALS
	-- SERIAL AND BIGSERIAL - AUTOINCREMENTING INTEGERS USED AS PK WHEN PK IS NOT APPARENT.
	-- PSQL CREATES INTEGER COLUMN . CREATES SEQUENCE OBJECT ON THIS NAMED - TABLE_NAME_COLUMN_NAME_SEQ
	-- ALTER THAT SEQUENCE USING ALTER SEQUENCE COMMAND.

	/*
		1. SEQUENCE CAN BE CREATED INDEPENDTENTLY FROM TABLE USING THE CREATE SEQUENCE COMMAND.
		2. THE SAME SEQUENCE CAN THEN BE USED FOR MULTIPLE TABLES.	
		3. INORDER TO THIS FOR MULTIPLE TABLES, DEFINE THE COLUMN AS INTEGER,BIGINT
		4. NEXT VALUE OF THE SEQUENCE CAN BE GENERATED FROM -> ** NEXTVAL(SEQUENCE_NAME) FUNCTION.
	*/
	CREATE TABLE TABLE_NAME ( USERID BIGINT); -- EXAMPLE BIGINT USAGE
	CREATE TABLE TABLE_NAME ( USERID SERIAL); -- EXAMPLE SERIAL USAGE
	CREATE TABLE TABLE_NAME ( USERID BIGSERIAL); 

-- GENERATE SERIES FUNCTION
	-- MIMICS A FOR LOOP IN GENERAL. HELPS US CREATE SERIES IN POSTGRES.
	SELECT X FROM GENERATE_SERIES(1,51,13) AS X; -- LEAVING OUT THE INCREMENT USES DEFAUT VALUE 1.

	/*
		OUTPUT
		-------
		1
		14
		27
		40
	*/

/************** CHARACTERS AND STRINGS ***************/

-- 3 PRIMITIVE CHARACTER TYPES ARE : 
	1. CHARACTER(CHAR)
	2. CHARACTER VARYING(VARCHAR)
	3. TEXT

	/**
		* VARCHAR AND CHAR CAN HAVE VARYING SIZES
		* CHAR IS FOR FIXED LENGTH. USE IT FOR PHONE NUMBERS, ZIP CODES ETC.
		* CHAR IS RIGHT-PADDED.
		* ODBC HANDLES VARCHAR AND CHAR DIFFERENTLY. CHAR AND VARCHAR HAVE A CAP OF 1GB.
		* BEHIND THE SCENES, ANY DATA LARGER THAN 1GB GETS PUSHED TO TOAST
		* IN GENERAL USAGE MAKE VARCHAR CASE INSENSITITVE. STILL IT CAN BE USED AS AN INDEX.
		* FOR THIS WE HAVE TO OVERRIDE CHARACTERS. OVERRIDING CHARACTERS IS EASIER FOR VARCHAR THAN FOR TEXT.
	**/

-- STRING FUNCTIONS
	LPAD(); -- LEFT PADDING
	RPAD(); -- RIGHT PADDING
	LTRIM(); -- LEFT TRIM
	TRIM(); -- 
	BTRIM();
	SUBSTRING();
	-- CONCATENATION USING || 

	SELECT LPAD('AB',4,'0') AS AB_LPAD,RPAD('AB',4,'0') AS AB_RPAD,LPAD('ABCDE',4,'0') AS AB_LPAD_TRUNC;
	/*
		ab_lpad | ab_rpad | ab_lpad_trunc 
		---------+---------+---------------
		00AB    | AB00    | ABCD
	*/

	/** LPAD TRUNCATES IF STRING IS TOO LONG , RATHER THAN ADDING PADDING **/

	** TRIM FUNCTION **
	SELECT
	A AS A_BEFORE,
	TRIM(A) AS A_TRIM,
	RTRIM(A) AS R_TRIM,
	I AS I_BEFORE,
	LTRIM(I,'0') AS I_LT_0,
	RTRIM(I,'0') AS I_RT_0,
	TRIM(I,'0') AS I_T_0
	FROM ( SELECT REPEAT('',4) || I || REPEAT('',4) AS A,'0'|| I AS I FROM GENERATE_SERIES(0,200,50) AS I) AS X;

-- SPLITTING STRINGS INTO ARRAYS,TABLES OR SUBSTRINGS
	
	-- GETTING THE Nth ELEMENT OF A DELIMITED STRING
	SELECT SPLIT_PART('ABC.123.CDE','.',2) AS X;

	-- UNNEST AND STRING_TO_ARRAY
	SELECT UNNEST(STRING_TO_ARRAY('ABC.123.CDE','.')) AS X; -- UNNEST EXPANDS THE ARRAY CREATED BY STRING_TO_ARRAY;

-- REGULAR EXPRESSIONS AND PATTERN MATCHING
	-- FORMATTING A PHONE NUMBER USING BACK-REFERENCING
	SELECT regexp_replace( 
		'6197306254', 
		'([0-9]{3})([0-9]{3})([0-9]{4})',
		E'\(\\1\) \\2-\\3' )
		As X;

	-- The \\1, \\2, etc. refer to the elements in our pattern expression. 
	-- We use the reverse solidus (\) to escape the parentheses. 
	-- The E' construct is PostgreSQL syntax for denoting that a string 
	-- is an expression so that special characters like \ are treated literally.

-- TEMPORALS
	-- POSTGRES HAS 9 TEMPORAL TYPES
		-- DATE - STORES MONTH, DAY AND EAR
			
		-- TIME - TIME WITHOUT TIME ZONE
		-- TIMESTAMP -- TIMESTAMP WITHOUT TIMEZONE
		-- TIMESTAMPTZ -- TIMESTAMP WITH TIMEZONE
		-- TIMETZ -- TIME WITH TIMEZONE
		-- INTERVAL -- ALLOWS TO DEFINE INTERVAL STARTING FROM NOW
		-- TSRANGE -- RANGE OF TIMESTAMP
		-- TSTZRANGE -- RANGE OF TIMEZONE SPECIFIC TIMESTAMP

		/* WE ARE NOT USING TIMESTAMP ACCORDING TO TIME_ZONE. SO LEAVING THAT FOR LATER. */

-- TIME ZONES : WHAT ARE THEY AND WHAT THEY ARE NOT
   ------------------------------------------------

	-- THIS QUERY TAKES INTO CONSIDERATION TIME ZONE AND THUS DST TOO, THUS GIVING INCORRECT RESULT.
	-- The key to the solution is that the change to DST occurred during the flight—the clocks sprang forward
	 SELECT '2012-03-11 3:10 AM America/Los_Angeles'::TIMESTAMPTZ - '2012-03-11 1:50 AM America/Los_Angeles'::TIMESTAMPTZ; 

	 -- THE CORRECT QUERY WOULD BE :
	 SELECT '2012-03-11 3:10 AM'::TIMESTAMP - '2012-03-11 1:50 AM'::TIMESTAMP;

-- DATETIME OPERATORS AND FUNCTIONS
	-------------------------------

	-- The query is asking: what time is it in Paris if it’s 2012-02-28 10:00 p.m. in Los Angeles?
	SELECT '2012-02-28 10:00 PM America/Los_Angeles'::timestamptz AT TIME ZONE 'Europe/ Paris';

	-- THE + OPERATOR ADDS AN INTERVAL TO A TEMPORAL TYPE.
	-- WITH INTERVAL, WE CAN ADD AND SUBTRACT TIME BY DIRECTLY USING ARITHMETIC OPERATORS.
	SELECT '2012-02-10 11:00 PM'::TIMESTAMP + interval '1 hour';

	-- ADDING INTERVALS TO INTERVALS
	SELECT '23 hours 20 minutes'::INTERVAL + '1 hour'::INTERVAL;

	-- SUBTRACTING INTERVALS FROM TEMPORAL TYPE
	SELECT '2012-02-10 11:00 PM'::TIMESTAMPTZ - interval '1 hour';

	-- OVERLAPPING
	-- AN OVERLAP CONSIDERS THE TIME PERIODS TO BE HALF OPEN, MEANING THAT THE START TIME IS INCLUDED BUT THE END TIME IS OUTSIDE THE RANGE.
	SELECT ('2012-10-25 10:00 AM'::TIMESTAMP, 
			'2012-10-25 2:00 PM'::TIMESTAMP) 
	OVERLAPS 
			('2012-10-25 11:00 AM'::TIMESTAMP,
			'2012-10-26 2:00 PM'::TIMESTAMP) AS x, 
	('2012-10-25'::date,'2012-10-26'::date) 
	OVERLAPS 
	('2012-10-26'::date,'2012-10-27'::date) As y;

	-- USING GENERATE_SERIES WITH TEMPORAL_DATATYPES.
	-- THIS QUERY GIVES BACK LAST DAY OF THE MONTH.
	SELECT(DT - INTERVAL'1 DAY')::DATE AS EOM
	FROM GENERATE_SERIES('2/1/2012','6/30/2012',INTERVAL '1 MONTH') AS DT;

	-- EXTRACTING ELEMENTS OF A DATE-TIME
	SELECT DT, 
	DATE_PART('hour',dt) As MH, 
	TO_CHAR(DT, 'HH12:MI AM') As TM
	FROM
	GENERATE_SERIES( '2012-03-11 12:30 AM', '2012-03-11 3:00 AM', INTERVAL '15 minutes' ) AS DT;

	-- BY DEFAULT GENERATE_SERIES ASSUMES TIMESTAMPTZ IF YOU DON'T EXPLICITLY CAST VALUES TO TIMESTAMP

-- ARRAYS 
   ------

	/* In PostgreSQL, every data type has a companion array type. 
	If you define your own data type, PostgreSQL creates a corresponding 
	array type in the background for you. For example, integer has an 
	integer array type integer[], character has a character array 
	type character[], and so forth. 
	*/
 
-- ARRAY CONSTRUCTORS
   ------------------

	-- /* USING AN ARRAY IN POSTGRES */
	SELECT ARRAY[2001,2002,2003] AS YRS;

	-- GET DATA FROM LOGS TABLE AND THEN USE TO POPULATE THE ARRAY
	SELECT ARRAY(
		SELECT DISTINCT DATE_PART('YEAR', LOG_TS) 
		FROM LOGS 
		ORDER BY DATE_PART('year', LOG_TS)
	);

	-- THIRD EXAMPLE
	SELECT '{Alex,Sonia}'::TEXT[] AS NAME, '{43,40}'::SMALLINT[] AS AGE;

	-- STRING TO ARRAY DELIMITED STRING
	SELECT STRING_TO_ARRAY('CA.MA.TX', '.') AS SOMETHING;

	-- array_agg() is a variant aggregate function that can take a set of any data type and convert it to an array
	SELECT ARRAY_AGG(log_ts ORDER BY log_ts) As x
	FROM logs
	WHERE log_ts BETWEEN '2011-01-01'::TIMESTAMPTZ AND '2011-01-15'::TIMESTAMPTZ;

-- REFERENCING ELEMENTS IN AN ARRAY
	-- ARRAYS IN POSTGRES START FROM 1.
	-- BY ACCESSING INDEXOUT OF BOUNDS NO ERROR IS RETURNED. NULL IS RETURNED.
	-- ARRAY UPPER CHECKS THE UPPER BOUND OF THE ARRAY.
	SELECT fact_subcats[1] AS primero, 
	fact_subcats[ARRAY_UPPER(fact_subcats, 1)] As segundo
	FROM census.lu_fact_types;

-- ARRAY SLICING AND SPICING
	-- IT RETURNS ANOTHER ARRAY THAT IS A SUB-ARRAY OF THE ORIGINAL
	SELECT fact_subcats[2:4] FROM census.lu_fact_types;
	-- TO GLUE 2 ARRAYS TOGETHER USE CONCATENATION
	SELECT fact_subcats[1:2] || fact_subcats[3:4] FROM CENSUS.lu_fact_types;

-- DEFINING RANGE TYPES
   --------------------

	-- BUILT-IN RANGE TYPES
	   --------------------

	-- RANGE OF INTEGERS -> INT4RANGE, INT8RANGE - INTEGER RANGE IS DISCRETE.
	-- NUMRANGE  -> A CONTINOUS RANGE OF FLOATING POINTS.
	-- DATERANGE -> A DISCRETE DATE RANGE OF CALENDAR DATES WITHOUT TIME ZONE AWARENESS.
	-- TSRANGE , TSTZRANGE -> A CONTINUOUS DATE AND TIMESTAMP - WITH TIMEZONE,WITHOUT TIMEZONE.

-- DEFINING RANGES
   ---------------
	-- A RANGE, REGARDLESS OF TYPE IS ALWAYS COMPOSED OF 2 ELEMENTS OF THE SAME TYPE WITH 
	-- BOUNDING CONDITION SET BY [] OR ();

-- DEFINING RANGES WITH CASTS
	SELECT '[2013-01-05,2013-08-13]'::DATERANGE;
	SELECT '(2013-01-05,2013-08-13]'::DATERANGE;
	SELECT '(0,)'::INT8RANGE;
	SELECT '(2013-01-05 10:00,2013-08-13 14:00]'::TSRANGE;

-- CREATING TABLE WITH DATERANGE
	CREATE TABLE EMPLOYMENT (
		ID SERIAL PRIMARY KEY, 
		EMPLOYEE VARCHAR(20), 
		PERIOD DATERANGE
	);

	CREATE INDEX IDX_EMPLOYMENT_PERIOD ON EMPLOYMENT USING GIST (PERIOD);

	INSERT INTO EMPLOYMENT(EMPLOYEE, PERIOD) 
	VALUES ('Alex', '[2012-04-24, infinity)'::DATERANGE), 
	('Sonia', '[2011-04-24, 2012-06-01)'::DATERANGE),
	('Leo', '[2012-06-20, 2013-04-20)'::DATERANGE),
	('Regi na', '[2012-06-20, 2013-04-20)'::DATERANGE);

-- HOW TO USE RANGE OPERATORS
	-- TWO RANGE OPERATORS ARE MORE IMPORTANT THAN ANY OTHER RANGE OPERATORS : 
	-- OVERLAP (&&) AND CONTAINS (@>)

	-- OVERLAP OPERATOR
	SELECT E1.EMPLOYEE, 
	STRING_AGG(DISTINCT E2.EMPLOYEE, ', ' ORDER BY E2.EMPLOYEE) AS COLLEAGUES
	FROM EMPLOYMENT As E1 
	INNER JOIN EMPLOYMENT As E2
	ON E1.PERIOD && E2.PERIOD -- PERIOD OF 1 EMPLOYEE OVERLAPS PERIOD OF ANOTHER EMPLOYEE
	WHERE E1.EMPLOYEE <> E2.EMPLOYEE 
	GROUP BY E1.EMPLOYEE;

	-- USING CONTAINS OPERATOR
	SELECT EMPLOYEE FROM EMPLOYMENT WHERE 
	PERIOD @> CURRENT_DATE GROUP BY EMPLOYEE ;

	-- REVERSE
	-- THE REVERSE OF THE CONTAINS OPERATOR IS THE CONTAINED OPERATOR(<@) - FIRST ARGUMENT IS VALUE AND SECOND IS RANGE

-- JSON 
   -----

   -- JSON AND JSONB ARE THE DATA TYPES IN POSTGRES SINCE POSTGRES 9.3

	-- INSERTING JSON DATA
	----------------------
	CREATE TABLE FAMILIES_J
	(
		ID SERIAL PRIMARY KEY, 
		PROFILE JSON
	);
	INSERT INTO FAMILIES_J (PROFILE) VALUES ( '{"name":"Gomez", "members":[ {"member":{"relation":"padre", "name":"Alex"}}, {"member":{"relation":"madre", "name":"Sonia"}}, {"member":{"relation":"hijo", "name":"Brandon"}}, {"member":{"relation":"hija", "name":"Azaleah"}} ]}');

	-- FUNCTIONS TO EXTRACT JSON
	----------------------------

	JSON_EXTRACT_PATH()
	JSON_ARRAY_ELEMENTS()
	JSON_EXTRACT_PATH_TEXT()

	SELECT JSON_EXTRACT_PATH(PROFILE, 'name') AS FAMILY, 
	JSON_EXTRACT_PATH_TEXT(JSON_ARRAY_ELEMENTS(JSON_EXTRACT_PATH(PROFILE,'members') ),'member','name' ) AS MEMBER
	FROM FAMILIES_J;

	-- OPERATORS 
	-- '->>' & '#>>' operators are shorthand for json_extract_path_text();

	-- CONVERTING ROW TO INDIVIDUAL JSON OBJECTS
	SELECT ROW_TO_JSON(F) AS X
	FROM (SELECT ID, PROFILE->>'name' AS NAME FROM FAMILIES_J) 
	AS F;

	SELECT ROW_TO_JSON(F) FROM FAMILIES_J AS F;

	-- BINARY JSONB
	---------------

	-- JSONB IS INTERNALLY STORED AS A BINARY OBJECT AND DOES NOT MAINTAIN THE FORMATTING OF THE ORIGINAL JSON TEXT AS THE JSON DATA TYPE DOES.
	-- SPACES AREN’T PRESERVED, NUMBERS CAN APPEAR SLIGHTLY DIFFERENT, AND ATTRIBUTES BECOME SORTED
	-- JSONB DOES NOT ALLOW DUPLICATE KEYS AND SILENTLY PICKS ONE, WHEREAS THE JSON TYPE PRESERVES DUPLICATES
	-- JSONB PERFORMANCE IS MUCH BETTER THAN JSON PERFORMANCE BECAUSE JSONB DOESN’T NEED TO BE REPARSED DURING OPERATIONS
	-- JSONB COLUMNS CAN BE DIRECTLY INDEXED USING THE GIN INDEX METHOD
													   ----------------
	CREATE TABLE FAMILIES_B (ID SERIAL PRIMARY KEY, PROFILE JSONB);	
	INSERT INTO FAMILIES_B (PROFILE) VALUES ( '{"name":"Gomez", "members":[ {"member":{"relation":"padre", "name":"Alex"}}, {"member":{"relation":"madre", "name":"Sonia"}}, {"member":{"relation":"hijo", "name":"Brandon"}}, {"member":{"relation":"hija", "name":"Azaleah"}} ]}');
	SELECT PROFILE As B FROM FAMILIES_B WHERE ID = 1;
	SELECT PROFILE AS J FROM FAMILIES_J WHERE ID = 4;

	-- JSONB REFORMATS INPUT AND REMOVES WHITESPACE. 
	-- ALSO, THE ORDER OF RELATION AND NAME ATTRIBUTES IS FLIPPED FROM THEIR ORIGINAL ORDER.
	-- JSON MAINTAINS INPUT WHITESPACE AND THE ORDER OF ATTRIBUTES.

	-- JSON B CONTAINS OPERATOR 
	SELECT PROFILE->>'name' As family
	FROM FAMILIES_B
	WHERE PROFILE @> '{"members":[{"member":{"name":"Alex"} }]}';

	-- CREATING A GIN INDEX
	CREATE INDEX IDX_FAMILIES_JB_PROFILE_GIN ON FAMILIES_B USING GIN (PROFILE);
